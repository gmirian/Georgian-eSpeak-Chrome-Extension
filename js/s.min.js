function Espeak(t,e){this.worker=new Worker(t),this.ready=!1,this.worker.onmessage=function(t){"ready"===t.data&&(this.worker.onmessage=null,this.worker.addEventListener("message",this),this.ready=!0,e&&e())}.bind(this)}function _createAsyncMethod(t){return function(){var e=arguments[arguments.length-1],s={method:t,args:Array.prototype.slice.call(arguments,0)}
if("function"==typeof e){var i="_"+t+"_"+(""+Math.random()).substring(2)+"_cb"
this[i]=e,s.args.pop(),s.callback=i}this.worker.postMessage(s)}}function PushAudioNode(t,e,s){this.start_callback=e,this.end_callback=s,this.samples_queue=[],this.context=t,this.scriptNode=t.createScriptProcessor(1024,1,1),this.connected=!1,this.sinks=[],this.startTime=0,this.closed=!1,this.track_callbacks=new Map}Espeak.prototype.handleEvent=function(t){var e=t.data.callback
return e&&this[e]?(this[e].apply(this,t.data.result),void(t.data.done&&delete this[e])):void 0}
var funcArr=["listVoices","get_rate","get_pitch","set_rate","set_pitch","setVoice","synth"]
for(var i in funcArr)Espeak.prototype[funcArr[i]]=_createAsyncMethod(funcArr[i])
PushAudioNode.prototype.push=function(t){if(this.closed)throw"can't push more chunks after node was closed"
if(this.samples_queue.push(t),!this.connected){if(!this.sinks.length)throw"No destination set for PushAudioNode"
this._do_connect()}},PushAudioNode.prototype.close=function(){this.closed=!0},PushAudioNode.prototype.connect=function(t){this.sinks.push(t),this.samples_queue.length&&this._do_connect()},PushAudioNode.prototype._do_connect=function(){if(!this.connected){this.connected=!0
for(var t in this.sinks)this.scriptNode.connect(this.sinks[t])
this.scriptNode.onaudioprocess=this.handleEvent.bind(this)}},PushAudioNode.prototype.disconnect=function(){this.scriptNode.onaudioprocess=null,this.scriptNode.disconnect(),this.connected=!1},PushAudioNode.prototype.addTrackCallback=function(t,e){var s=this.track_callbacks.get(t)||[]
s.push(e),this.track_callbacks.set(t,s)},PushAudioNode.prototype.handleEvent=function(t){this.startTime||(this.startTime=t.playbackTime,this.start_callback&&this.start_callback())
var e=t.playbackTime-this.startTime,s=this.scriptNode.bufferSize/this.context.sampleRate
for(var i in this.track_callbacks){var a=this.track_callbacks[i],o=a[0],c=a[1]
if(e>o)this.track_callbacks["delete"](o)
else if(e+s>o){for(var i in c){var n=c[i]
n()}this.track_callbacks["delete"](o)}}for(var r=0;this.samples_queue.length&&r<t.target.bufferSize;){var h=this.samples_queue[0],u=h.subarray(0,t.target.bufferSize-r)
t.outputBuffer.copyToChannel?t.outputBuffer.copyToChannel(u,0,r):t.outputBuffer.getChannelData(0).set(u,r),r+=u.length,h=h.subarray(u.length),h.length?this.samples_queue[0]=h:this.samples_queue.shift()}!this.samples_queue.length&&this.closed&&(this.end_callback&&this.end_callback(t.playbackTime-this.startTime),this.disconnect())}
